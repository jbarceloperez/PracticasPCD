##################################
### PSEUDOCÓDIGO PRÁCTICAS PCD ###
##################################

# EJERCICIO 1 #

program ejercicio1;
var
	l: lock;

process type HiloOrdenAlfabetico(id : integer, frases : array[0..49] of string);
var
	frase , ordenada: string;
	palabras : array[] of string;	

begin
	frase := frases[id];
	palabras := frase.split(" ");	// se separa la cadena original en un array de cadenas formadas
									// por las diferentes palabras que la formaban separadas por espacios.
	palabras.sort();	// se ordenan alfabéticamente las diferentes palabras
	ordenada := palabras[0];
	for i:=1 to (palabras.length - 1) do
		ordenada := ordenada + " " + palabras[i];
	l.lock;	//sección crítica al imprimir 
	writeln("Hilo ID: " + id);
	writeln("Frase original: " + frase);
	writeln("Frase ordenada: " + ordenada);
	writeln("Fin hilo ID: " + id);
	l.unlock; // fin sección crítica
end;
	

const
	NUMTHREADS : 50;
	NUMFRASES : 50;

var
	thrs : array[1..NUMTHREADS] of HiloOrdenAlfabetico;
	frases : array[1..NUMFRASES] of string;
	
begin
	//generar array de 50 frases
	for i:=1 to NUMFRASES do
		frases[i] := generarFrase();
	
	cobegin
		for i:=1 to NUMTHREADS do
			thrs[i](i, frases);
	coend;
	// mutex
	
	writeln("Array");
	for i:=1 to NUMFRASES do
		writeln("Frase ",i,": ", frases[i]);
	writeln("Fin array");
end;



# EJERCICIO 2 #

program ejercicio2;
const
	NUMTHREADS : 20;
	TAMMATRIX : 10;

var
	semG, semP, mutex : semaphore;
	np, ne : integer;
	hueco : array[0..2] of boolean;

process type HiloMatriz(id : integer, paneles : array[0..3] of Panel);
var
	A, B, C : matriz of integer;
begin
	repeat 10
		//genera las matrices A y B
		tam := random(2,10);	//la suma de matrices es una op entre matrices del mismo tamaño
		for i:=0 to tam do
			for j:=0 to tam do
			begin
				A[i][j] = random(0,MAXNUM);
				B[i][j] = random(0,MAXNUM);
			end;
		//suma las matrices y guarda el resultado en C
		for i:=0 to tam do
			for j:=0 to tam do
				C[i][j] = A[i][j] + B[i][j];
		
		if (tam < 4) then
		begin	//sincronización
			wait(semP);
			//sección crítica
			paneles[3].escribir_mensaje(C);
			//fin sección critica
			signal(semP);
		end;
		else
		begin
			wait(mutex);	//sincronización	
			if (np=3) then
			begin
				ne++;		// un hilo más esperando
				signal(mutex); //deja seguir a otros hilos
				wait(semG);	//se deja el hilo a la espera
				ne--;		// un hilo menos esperando
			end;
			np++;		// un hilo más en sección crítica
			if (hueco[0]) then i := 0;
			else if (hueco[1]) then i := 1;
			else i := 2;
			hueco[i] := false;	//el panel i pasa a ocupado
			signal(mutex);	
			//sección crítica
			paneles[i].escribir_mensaje(C);
			//fin seccion crítica
			wait(mutex);//sincronización
			np--;	// un hilo más en sección crítica
			hueco[i] := true;	//el panel i pasa a libre
			if (ne > 0) then signal(semG);
			else signal(mutex);
		end;
	end;
end;

var
	thrs : array[1..NUMTHREADS] of HiloMatriz;
	paneles : array[0..3] of Panel
	
begin
	
	//inicializar hilos
	cobegin
		for i:=0 to NUMTHREADS do
			thrs[i](i, paneles);
	coend;
end;


# EJERCICIO 3 #

program Ejercicio3;

monitor monitor();
const 
	NUMCAJAS : 3;
var
	cajas : array [0..NUMCAJAS-1] of condition;
	tiempos : array [0..NUMCAJAS-1] of integer;

export
	entrar_cola, salir_cola, imprimir;

procedure entrar_cola(y : integer)
var
	tMin, ncaja : integer;
// en exclusión mútua porque es un procedimiento de monitor
begin	
	min := tiempos[0];
	for i:=1 to NUMCAJAS do
		if (min < tiempos[i]) then
		begin
			tMin := tiempos[i];
			ncaja := i;
		end;
	tiempos[ncaja] := tiempos[ncaja] + y;
	if (not tiempos[ncaja] = y)	then //si hay clientes en cola
		delay(cajas[ncaja]);
	return ncaja;
end;

procedure salir_cola(y, ncaja : integer)
begin	// en mutex
	tiempos[ncaja] := tiempos[ncaja] - y;
	resume(cajas[ncaja]);
end;

procedure imprimir(id, ncaja, x, y : integer)
begin	//se debe imprimir en exclusión mutua ya
		//que la salida por pantalla no es compartible
	writeln("Cliente "+id+" será atendido en caja "+ncaja);
	writeln("Tiempo de compra "+ x);
	writeln("Tiempo estimado en caja "+ y);
	writeln("Tiempo de espera cola1=" + tiempos[0]+
			",cola2="+tiempos[1]+",cola3="+tiempos[2]);
end;

begin
	for i:=0 to NUMCAJAS do
		tiempos[i] := 0;
end;

process type HiloCliente(id : integer, monitor : Monitor);
var
	x, y, ncaja;
begin
	id := id;
	x := random();
	y := ranodm();
	sleep(x); //hacer la compra
	ncaja := monitor.entrar_cola(y);
	//sección crítica
	monitor.imprimir(id, x, y, ncaja)
	sleep(y);	//pagar en caja
	//fin sc
	monitor.salir_cola(y, ncaja);
end;

const
	NUMTHREADS : 50;
var
	hilos : array [0..NUMTHREADS-1] of HiloCliente;

begin
	monitor; //inicializar monitor
	cobegin	//inicializar los 50 hilos
		for i:=0 to NUMTHREADS do
			array[i](i, monitor);
	coend;
end;





